## 문제 조건
### 빌딩 건설

- 빌딩의 주소 = 빌딩의 가장 왼쪽 셀 주소
- 빈공간을 찾는 방법
  - 토지 내에서 가장 긴 빈공간을 선택
  - 가장 긴 빈공간이 여러 개면 가장 왼쪽에 위치한 빈공간을 선택

- 빌딩은 빈 공간에서 가운데 위치하도록 건설
오른쪽의 빈공간이 0~1 더 커야함.

## 빌딩 제거
셀의 주소가 주어지면, 그 주소와 동일한 주소를 가진 빌딩을 제거
빌딩의 주소가 아니면 아무 일도 발생되지 않음.


## 아이디어
- build, demolish 모두 O(N) 미만의 시간복잡도 필요할 듯함.
- 빈공간의 길이가 최대값인 space를 꺼내야함. -> 우선순위 큐 선택(우선순위 정의 필요)
- 빌딩 건설 시 빈공간이 2개로 쪼개짐. 나중에 빌딩을 제거하면 다시 합쳐지기 때문에 HashMap에 idx로 저장해야겠다. 
- 빌딩의 idx로 제거하기 위해 HashMap 사용
- 빈공간을 어떻게 다시 붙일까? 빌딩의 양 옆에 빈공간이 있는데, 왼쪽 빈공간의 right, 오른쪽 빈공간의 left는 쪼개질때마다 갱신되므로
  왼쪽 끝, 오른쪽 끝 idx로 Space를 두개씩 넣고 꺼내서 합치면 되겠다고 생각함. => HashMap 필요

### 시간복잡도
init(): 1 <br>
build(): O(logN) * 20,000 ->대략 18.xx 300 이내<br> 
demolish(): O(logN) * 6,000 -> 1000 이내

## 자료구조
- Space, Building: left, right, len을 가짐. 
- HashMap<Integer, Building>: 빌딩을 저장 
- HashMap<Integer, Space>: 빈공간을 저장
- PriorityQueue<Space>: Space용 우선순위 큐


## 구현

### init()
- 초기화 및 맨 처음 빈공간 삽입


### build(int mLength)
- 빈공간이 있고 빌딩이 빈공간보다 길이가 짧아야함.
- 빌딩을 설치하면 빈공간이 안생길수도 있고 2개까지 생길 수도 있다.
- PQ에서 빈공간을 꺼내 사용했다면 Map에서 해당 space 제거해야함.
- space를 두 개씩 넣는다.

### demolish(int mAddr)
- 빌딩을 제거 가능하다면 제거한다.
- 그로 인해 최소 빌딩 크기만큼의 빈공간이 생기며 좌우에 빈공간이 있다면 길어짐.
- 문제점! PQ에서 최대값이 아닌 빈공간을 찾아서 제거해야함. O(N) => isRemoved로 build할 때 제거하자.
- build에서 제거하는 로직 추가
- 새로운 빈공간 PQ와 Map에 추가