# 📖 단어암기장

## 1. 문제 요약
- **문제 핵심 내용:**  N * M 단어장에 단어 쓰고 지우기
- **입력 조건:** 세로 N, 가로 M, 단어 정보(ID, mLen)
- **출력 조건:**  
1) void init(): 행 N 열 M
2) int writeWord(int mId, int mLen)
- ID가 mId, 길이가 mLen인 단어
- 규칙에 맞게 단어 넣고, 쓰여진 위치의 행 번호 return
- 넣을 수 없으면 -1 
3) int eraseWord(int mId)
- ID가 mId인 단어 암기
- 지우기 전에 적힌 행 번호 return
- 지울 수 없으면 -1 return 

- **제약 사항:**  
1) 단어들의 위치는 중복될 수 없음
2) 하나의 단어는 한 줄에 적혀야 함
3) 단어 위치 우선순위 -> 1 행 2 열 번호 작은 순
4) 삭제 시: 사용하던 셀은 모두 빈 공간

- 암기장의 길이가 긴 경우 동일한 크기로 잘라서 사용? 
---

## 2. 접근 방식

### 2-0 자료구조
- TreeSet<Vacant> wordBook: 단어장의 빈 공간을 저장하는 TreeSet, r asc c asc로 정렬
- HashMap<Integer, int[]> words: mId를 넣으면 (r, c, length)를 돌려주는 Map
- private int[] bucketMax: 각 행의 가장 긴 빈칸 길이를 저장하는 배열
- class Vacant : int r, int c, int len ->빈 공간의 시작점과 길이를 저장

### 2-1. 생각
- 이번엔 클래스 만들어서 풀기...
- 암기장 왜 자르라고 할까 왜지
- 이것도 pq에 넣으면 될까?
- 근데 우선순위는 번혼데, 일단 크기가 넘어야하긴 하잖아..
- 1. 크기... 2. 번호...?
- TreeSet에 Iterator가 있다는 것을 알게 되었습니다(by 회인님) -> remove()로 지울 수 있는 듯
- TreeSet에 넣고, Iterator로 돌다가 가장 위에 있는, 넣을 수 있는 첫 번째 자리에 넣기

### 2-2. 해결 흐름(단계별 로직)
1) writeWord(int mId, int mLen):
- mLen이 M보다 길면 쓸 수 없으므로 -1 return
- wordBook에서 단어를 넣을 수 있는(r / c가 가장 작은) 칸 찾기 -> 버킷 활용
- bucketMax[b] >= mLen인 버킷을 찾아서
- 버킷이 담당하는 행 구간에 있는 vacant들 중에서 넣을 자리 찾기
- 새로운 빈 공간: c + mLen

-> Vacant canWrite(int mLen):
- 1: 버킷 단위로 돌면서 mLen 이상의 빈 칸이 있는 버킷 찾기
- 2: 찾은 버킷에 속하는 행 중 

2) eraseWord(int mId):
- 못 찾으면 return -1
- 지우고 빈칸 정리(앞칸, 뒷칸 합치기) -> building 지우던 거랑 동일
- 이전 빈 칸의 마지막 칸이 지운 칸의 시작점 - 1과 동일
- 다음 빈 칸의 첫 칸이 지운 칸의 끝점 + 1과 동일
- 그리고 속한 버킷만 다시 최대 길이 계산
---

## 3. 시행착오 및 개선
- **초기 접근 방식:** 넣은 단어들을 시작점, 끝점만 표기
- **문제가 되었던 부분:** 단어들 뺄 때 길이가 필요하다는 것을 깨달음...
- **최종 해결 방식:** Word 클래스 새로 만들기, 근데 사실 Vacant로 써도 되긴 함

아 시간초과났어!!
끊어서 책처럼 관리하라는 게 이 부분인가?
- **초기 접근 방식:** 빈 칸들을 모두 하나의 TreeSet에 저장
- **문제가 되었던 부분:** 들어갈 자리 찾는 과정에서 시간 초과
- **최종 해결 방식:** 어뜨카지? 버킷 알고리즘 적용하기
    -> 행마다 묶고, 버킷에서 가장 긴 빈 칸 길이를 기억하기
    버킷 크기: sqrt(N) 해버리기

---

## 4. 회고
- **배운 점:** 버킷...세그먼트트리... 공부하기
