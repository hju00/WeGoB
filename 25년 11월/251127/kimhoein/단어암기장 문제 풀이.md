# [pro] 단어암기장 문제 풀이

## 문제 분석

버킷?
행보다는 열이 작으니 열을 나눠서 하면 효율적 일 수 있지 않을까?

추가
단어 끼리 겹치면 안됨
가장 작은 행에 추가
한 행을 넘기지 말 것

삭제
id 이용해서 삭제

## 알고리즘 선정
트리셋을 사용해서 행, 열 순으로 정렬 해두고
만약
treeset<class>[M/100] 10(0~99 , 100~199 ...)
treeset[] <class> [5~20000] 행 



## 수도 코드
```
class
행
열
길이



treeset<class>[M/100] 10(0~99 , 100~199 ...)
treeset[] <class> [5~20000] 행 
init

for(0..N)
treeset<class>[M/100].put(i,0,N) (행은 하나씩 증가, 열은 초기에는 0, 길이 또한 초기값 N)


writeWord(mid,mLen)

int h_min = N+1 초기 값 줘서 뭐가 들어와도 업데이트
int count =-1;	// 업데이트 될때 

for(mLen/100 ... 10)
{
	if(min.key < treeset 맨위에꺼 행)	min.key = 행 , count
}

if(count == -1) 업데이트 안되었으면 -1 리턴

가장 작은 카운트 구하고 
class = treeset[count].pop

if(class.d != mLen) 
	class.d = class.d - mLen;
	class.열 + mLen;
	treeset[class.d/100].put(class)
	hashmap.put(id,class)


remove

hash.contain(mid) 라면

행  class.left 
행  class.right

각각 null이 아니라면
class.left로 나온 class에서 나온 treemap 제거
treemap class.열 = class.left 열
treemap class.d += class.left.d

treemap[class.left.d/100].remove(treemap) 및
treemap행[] 삭제 

class.right 나온 class에서 tremap 제거
treemap class.duf = class.right 열
treemap class.d += class.right.d

treemap[class.right.d/100].remove(treemap) 및
treemap행[] 삭제

합쳐진 treemap class
treemap[treemap.d/100] 
```
