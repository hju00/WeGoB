# 아이디어

* 이벤트 시간이 증가하는 특성을 이용해 **요청 단위로 진행량을 누적**한다.
* 다운로드 가능 여부는 **최단 경로 길이 ≤ 5000** 조건으로 판단한다.
* 링크/공유 파일 추가 시 기존 요청에 **즉시 반영**되도록 소스 수를 갱신한다.

1. **시간 축 시뮬레이션 중심**

  * 모든 API 호출마다 `advanceTime(mTime)`을 먼저 수행해 누적 진행량을 계산한다.
  * 진행량 = `dt * 9 * 소스 수`로 단순화하여 유지한다.

2. **거리 기반 소스 집계**

  * `makeNet`에서 제한 Dijkstra로 모든 쌍 최단거리(≤5000)를 계산한다.
  * `addLink`는 신규 링크를 경유하는 경로만 O(N^2)로 갱신한다.

3. **요청 상태 관리**

  * `(컴퓨터, 파일)` 단위 `Request`를 만들어 `downloaded`, `rateSources` 등을 관리한다.
  * 소스 수 변화가 발생하면 이후 다운로드 속도에 즉시 반영한다.

# 접근 로직

## 1. 초기화

* `init`에서 공유 파일 목록을 구성하고 `hasFile`로 보유 여부를 기록한다.
* 그래프와 거리 행렬을 초기화한다.

## 2. 거리 계산

* `makeNet`에서 모든 노드에 대해 제한 Dijkstra를 수행하여 `dist`를 구성한다.

## 3. 이벤트 처리

### `addLink`
* 시간 진행 → 거리 갱신 → 활성 요청의 소스 수 재계산

### `addShareFile`
* 시간 진행 → 공유 파일 추가 → 해당 파일 요청자만 소스 수 증가

### `downloadFile`
* 시간 진행 → 요청 생성/조회 → 도달 가능한 소스 수 반환

### `getFileSize`
* 시간 진행 후 반환
* 공유 파일이면 요청 없이도 크기 반환

# 자료구조

* `dist[com][com]` : 최단 거리(≤5000), 초과는 `CAP=5001`
* `FileInfo` : 파일 크기, 공유 중인 컴퓨터 목록
* `Request` : 다운로드 진행 상태 (downloaded, rateSources, lastTime, completed)
* `hasFile[com][fileIdx]` : 해당 컴퓨터가 공유 파일을 보유하는지 여부

# 시간 복잡도

* `makeNet` : N회 제한 Dijkstra
* `addLink` : O(N^2) 거리 갱신 + 활성 요청 재계산
* 요청/파일 수 제한(≤1500/≤500) 내에서 충분히 동작

# 구현 포인트

* `getFileSize`는 **공유 파일이면 요청 여부와 무관하게 크기 반환**해야 샘플과 일치한다.
* 다운로드 완료 파일은 **공유로 전파되지 않는다**.