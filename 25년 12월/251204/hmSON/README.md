# [pro] 단어암기장 문제 풀이

## 문제 분석

최대 $100,000$개의 열차 역과, 최대 $200$개($50$개 초기 + $150$개 추가)의 직선으로 왕복 운행하는 열차가 주어진다. 각 열차는 최대 $10^9$ 범위의 ID, 시작역, 종착역, 정차역 간격 정보를 가진다. 출발 역에서 도착 역으로 가는 데 필요한 **최소 환승 횟수**를 구해야 한다.

- ❌ **거리 무관**: 이동한 물리적 거리는 중요하지 않으며, 오직 **환승 횟수**를 최소화하는 것이 목적이다.
- 💡 **알고리즘 선택**:
    - 최단 거리를 구하는 문제였다면 **다익스트라(Dijkstra)**를 고려했을 것이다.
    - 하지만 간선의 가중치가 없는(모든 환승 비용이 1로 동일한) 최단 경로 문제이므로 **BFS(너비 우선 탐색)**가 가장 적합하다.

<br>

## 문제에서 요구하는 쿼리 분석

### 1. `add(int mId, int sId, int eId, int mInterval)` : 열차 추가
- 새 열차를 추가한다. 각 열차의 ID는 $1$ ~ $10^9$ 사이의 값이다. (중복 ID 없음)
    - 🆔 **ID 관리**: 범위가 매우 크므로 배열 대신 `HashMap`을 사용하여 열차 정보를 관리해야 한다.
- 시작역과 종착역이 같은 경우는 없으며, 주어진 $N$을 넘어서는 역은 주어지지 않는다.
- 해당 열차는 `sId`와 `eId`를 포함하여 `mInterval` 간격인 범위 내 모든 역에서 정차한다.
    - ⚠️ **자료구조 주의**: $100,000$ 크기의 역 기반 자료구조 생성은 최대한 피해야 한다.
    - **핵심 전략**: 역을 일일이 기록하는 대신, **열차 간 환승 가능 여부**를 설명할 수 있는 효율적인 자료구조(기차 중심 그래프)를 구현해야 한다.

### 2. `remove(int mId)` : 열차 제거
- 열차를 제거한다. 존재하지 않거나 이미 삭제된 열차 ID는 주어지지 않는다.
- `HashMap`에서는 해당 열차 객체를 즉시 제거할 수 있다.
- 하지만 인접 행렬 등 다른 자료구조를 매번 갱신하는 것은 비효율적이므로 **지연 삭제(Lazy Deletion)** 방식을 고려한다.

### 3. `calculate(int sId, int eId)` : 최소 환승 경로 계산
- 출발 역(`sId`)과 목적지 역(`eId`)이 주어진다. 최소 환승 횟수를 반환해야 한다.
- 환승 없이 도착 가능한 경우도 있으며, 이동 불가능한 경우 `-1`을 반환한다.
- **탐색 전략**: 현재 위치(역 번호)를 기준으로 탐색하면 노드 수가 너무 많아 탐색 횟수가 폭증할 수 있다.
    - 🚀 **최적화**: 최대한 역 번호 순회를 배제하고, **기차 간의 연결 관계**만으로 **BFS 탐색**을 시도하여 탐색 공간을 획기적으로 줄여야 한다.

<br><br>

> ## 자료구조 및 알고리즘 설계
### 1. 기차 중심 그래프 모델링 (Train-Centric Graph)
- **역(Station) 기반 탐색의 비효율성 개선**: 역의 개수($N$)는 최대 100,000개에 달하지만, 기차($K$)의 개수는 최대 200개(초기 50 + 추가 150)로 매우 적다. 따라서 역을 노드로 두는 일반적인 그래프 대신, **기차 자체를 노드로, 환승 가능 여부를 간선(Edge)으로 하는 그래프**를 설계한다.
- **인접 행렬(Adjacency Matrix)**: 기차의 개수가 적으므로, 기차 간 연결 정보를 저장하기 위해 $200 \times 200$ 크기의 `boolean[][] adj` 배열을 사용한다. 이는 $O(1)$의 접근 속도를 보장하며 메모리 효율적이다.
- **ID 매핑**: 입력으로 주어지는 기차 ID는 최대 10억이므로, `HashMap<Integer, Integer>`를 사용하여 0부터 시작하는 내부 인덱스로 변환해 배열 및 그래프에서 관리한다.

### 2. 수학적 교차 검증 (Number Theory)
- 기차 간 환승 가능 여부(간선 생성)를 판단하기 위해 두 기차의 경로를 모두 순회하는 시뮬레이션 방식은 비효율적이다. 이를 **정수론적 성질**을 이용해 $O(1)$에 가깝게 최적화한다.
- **GCD(최대공약수) 활용**: 두 기차의 시작점 차이가 두 간격(Gap)의 최대공약수로 나누어 떨어지지 않으면, 두 기차는 절대 만날 수 없다. ($(s_2 - s_1) \% \text{GCD}(g_1, g_2) \neq 0$) 이 경우 즉시 탐색을 종료하여 불필요한 연산을 줄인다.
- **LCM(최소공배수) 활용**: 두 기차의 만남 패턴은 두 간격의 최소공배수 주기로 반복된다. 따라서 시뮬레이션을 하더라도 전체 구간($N$)이 아닌, $\text{LCM}(g_1, g_2)$ 범위까지만 확인하면 교차 여부를 확정할 수 있다.

### 3. BFS 탐색 및 지연 삭제 (Lazy Deletion)
- **BFS (너비 우선 탐색)**: 최소 환승 횟수는 가중치가 없는 그래프의 최단 경로 문제와 같으므로 BFS를 사용한다. 큐에는 `{기차 인덱스, 현재까지의 환승 횟수}`를 저장한다.
- **탐색 최적화**: 현재 탑승한 기차에서 환승 가능한 다음 기차(`nextTrain`)를 탐색할 때, 해당 기차가 목적지(`eId`)에 도달 가능한지 미리 확인(`canGo`)하여, 가능하다면 큐에 넣지 않고 즉시 결과를 반환한다.
- **지연 삭제**: `remove` 명령 시 그래프를 재구성하거나 배열 요소를 실제로 삭제하는 비용을 없애기 위해, 해당 기차 객체에 `isRemoved` 플래그만 `true`로 설정한다. 이후 BFS 탐색 과정에서 이 플래그를 확인하여 무시하는 방식으로 처리한다.