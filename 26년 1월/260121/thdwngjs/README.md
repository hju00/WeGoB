# 아이디어

* 맵의 크기()에 비해 게이트의 수와 최대 이동 거리(Stamina)가 제한적이라는 점에 주목했습니다.
* 매번 전체 맵을 탐색하는 것은 비효율적이라 판단

1. **단순 BFS/DFS 접근 (전체 맵 탐색)**

  * 처음에는 `getMinTime` 호출 시마다 시작 게이트에서 도착 게이트까지 맵 위에서 BFS를 수행하는 방식을 고려했습니다.
  * 하지만 격자판에서 최대 800번의 쿼리를 수행해야 하고, `addGate`로 인해 지형 정보(게이트 위치)가 계속 변하기 때문에 매번 맵 전체를 탐색하면 시간 초과가 발생할 것이라 예상했습니다.

2. **게이트 간의 논리적 그래프 구축 (최적화)**

  * 따라서, 던전의 모든 칸을 탐색하는 대신 **'게이트'를 노드로, '게이트 간의 이동 가능 여부'를 간선으로 하는 그래프**를 별도로 관리해야 한다고 생각했습니다.
  
    * **간선 연결 (`addGate`)**: 
    
      게이트가 추가될 때만 해당 위치에서 BFS를 수행하여, 도달 가능한 다른 게이트들과의 거리를 미리 계산해 인접 행렬(`adj`)에 저장합니다.
      
    * **최단 거리 조회 (`getMinTime`)**: 

      이미 구축된 게이트 간 그래프 위에서 다익스트라 알고리즘을 수행하면, 작은 수준의 그래프 탐색이 되므로 매우 빠르게 정답을 구할 수 있습니다.


3. **탐색 범위 제한을 통한 효율성 증대**
  * `addGate` 시 BFS를 수행할 때도, 기사의 최대 체력(`mMaxStamina`)만큼만 이동할 수 있다는 제약 조건을 활용했습니다.
  * 전체 맵을 다 볼 필요 없이, 시작점에서 반경 `mMaxStamina` 이내의 영역만 탐색하도록 가지치기(Pruning)를 적용하여 그래프 구축 비용을 최소화하였습니다.

# 핵심 로직

## 하이브리드 탐색 (BFS + Dijkstra)

격자형 맵에서의 BFS와 노드 기반의 다익스트라를 결합하여 문제를 해결했습니다.

### 1. 자료구조 최적화 및 초기화

* **좌표 압축 및 매핑**:  

  맵 전체를 저장하는 `map` 배열 외에,  좌표에 위치한 게이트 ID를 $O(1)$에 조회할 수 있도록 `gateGrid` 배열을 별도로 관리했습니다.

* **인접 행렬 활용**: 
  
  게이트의 개수가 최대 200개로 적기 때문에, 간선 관리에 인접 리스트보다 구현이 직관적이고 갱신이 빠른 `adj[201][201]` 인접 행렬을 사용했습니다.

### 2. 게이트 추가 시 부분 BFS (Topology Update)

`addGate` 함수가 호출되면 다음과 같은 로직으로 그래프를 갱신합니다.

* 새로운 게이트 위치를 `gateGrid`에 등록합니다.
* **제한된 BFS 탐색**: 해당 위치에서 BFS를 시작하되, 이동 거리가 `mMaxStamina`를 초과하면 더 이상 큐에 넣지 않습니다.
* **양방향 간선 연결**: 탐색 도중 활성화된 다른 게이트를 만나면, `adj` 행렬을 양방향(`Start ↔ End`)으로 갱신하여 두 게이트 사이의 최단 거리를 저장합니다.

### 3. 게이트 간 최단 경로 탐색 (Query Execution)

`getMinTime` 함수에서는 미리 구축된 `adj` 그래프를 기반으로 다익스트라 알고리즘을 수행합니다.

* **우선순위 큐(PQ)**: 

    `int[] {게이트ID, 누적거리}` 형태의 데이터를 담아 거리가 짧은 순서대로 탐색합니다.
    
* **가지치기 (Pruning)**: 
    
    현재까지의 거리가 이미 기록된 최단 거리보다 길다면 탐색을 중단하여 불필요한 연산을 방지합니다.
    
    `V` 가 작기 때문에 이 과정은 매우 빠르게 수행되며, 전체 수행 시간에 큰 영향을 주지 않습니다.