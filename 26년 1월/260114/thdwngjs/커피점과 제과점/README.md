# 아이디어
* 이전에 풀었던 문제이기에 따로 흐름을 정리하면 풀진 않았습니다.
* 이전에 생각하였던 풀이를 작성하였습니다.
1. 커피점과 제과점에서 출발해서 커세권과 제세권을 모두 만족하는 건물을 찾아야 함

   처음 풀이에서는 멀티소스 다익스트라 알고리즘을 한 번에 동작하여야 풀 수 있을 것 같다는 생각을 하였습니다.
  하지만 커피점에서 출발한 경로가 중간에 제과점에 도달할 경우 더 이상 탐색을 하지 않도록 작성하였는데요
  다음과 같은 경우를 조건을 만족하는 건물을 탐색할 수 없었습니다.
  커피점 - 제과점 - 집

2. 커피점과 제과점에서 출발하는 멀티소스 다익스트라 알고리즘을 각각 실행

    그런 이유에서 멀티소스 다익스트라 알고리즘을 각각 실행하여 조건을 만족하는 건물을 찾고자 하였습니다.
  이 경우에는 가장 최소값이 되는 건물인지 확인할 수 없기 때문에 전 건물을 탐색하여야 했습니다.
  이 과정에서 더 많은 시간 소요가 있었을 것으로 예상됩니다.

3. 커피점과 제과점에서 출발하는 멀티소스 다익스트라 알고리즘을 한번에 실행

    이런 이유로 멀티소스 다익스트라 알고리즘을 실행하기 위한 힙에 
   커피점과 제과점에서 출발하는 노드를 모두 넣고 알고리즘을 동작하도록 작성하였습니다.
   이 경우 커피점에서 출발한 노드가 제과점에서 출발한 노드가 이미 방문한 건물일 경우에 탐색 알고리즘을 종료하기 때문에
   전 건물의 거리를 탐색하지 않아도 된다는 시간적인 이점이 있습니다.
   이러한 이유로 시간복잡도가 감소하였다고 예상됩니다.

# 핵심 로직
## 유형별 동시 다익스트라 
(Simultaneous Multi-Source Dijkstra)
1. 그래프 구성

  * 각 건물을 노드로, 도로를 간선으로 하는 양방향 그래프를
  ArrayList<List<int[]>> 인접 리스트로 구현하였습니다.
  
2. 초기화 및 우선순위 큐(PQ) 설정

  * PriorityQueue에 **커피숍($Type=0$)**과 **제과점($Type=1$)**의 모든 시작점 노드를 cost = 0으로 삽입합니다.
  Edge 클래스에 type 필드를 추가하여, 현재 탐색이 어떤 출발지 그룹(커피/제과)에서 파생되었는지 구분합니다.
  
3. 방문 처리 및 거리 계산

  * visit[2][N] 2차원 배열을 사용하여 
  커피숍 출발 경로(visit[0])와 제과점 출발 경로(visit[1])의 최단 거리를 각각 독립적으로 저장합니다.
  
4. 교차점 확인 및 정답 갱신 (Pruning)
  
  * 특정 건물에 도착했을 때, 두 타입(0, 1) 모두 방문 기록이 존재한다면 해당 건물은 후보지가 됩니다.
  이때 두 거리의 합(totalDist)을 계산하여 최솟값(ans)을 갱신합니다.
  
  * 가지치기(Pruning)
    R (제한 거리)을 초과하는 경로
    이미 구한 ans보다 현재 거리가 긴 경우
    동일 타입으로 이미 방문한 경우
    위 경우에는 큐에 넣지 않고 탐색을 종료하여 시간을 단축합니다.
