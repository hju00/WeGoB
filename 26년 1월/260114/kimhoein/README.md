# 2026년 1월 2주차 문제 풀이 업로드 폴더입니다.
금주 선정 문제는 다음과 같습니다.
## [pro] 커피점 & 제과점

## 아이디어
이전에 풀었기 때문에 사실 큰 고민을 하지 않았었습니다.
조건은 카페 그리고 제과점 모두를 들릴 것
node 형태 그리고 최소 거리를 구해야 하기에 다익스트라
카페 - 집 - 제과점
실수로 카페 에서 제과점을 집으로 판정하지 않게 주의 할 필요가 있었습니다.

처음에는 다익스트라를 두번 했었기에 시간 복잡도 면에서 문제가 많았었습니다.
다익스트라에 커피 제과점 두개 모두 포함시켜서 한번에 돌리도록 하게 함 시간 복잡도 감소

추가 현재 값에서 R 이상 넘어가면 더이상 길찾기를 할 필요가 없어짐
추가2 현재 값에서 현재의 최소값 이상을 넘어가면 더이상 길찾기를 할 필요가 없어짐
이부분 주의 하면서 풀어서 최대한 시간 복잡도 감소에 노력했습니다.

ArrayList 사용 ArrayList 사용으로 조회시 시간을 빠르게 했습니다.


ArrayList<Node>[] adj;
인접 리스트로 관리

int[][] dist;
0,1로 나눠어서 빵집 카페 동시 관리

boolean[] isSpot;

PriorityQueue<Node> pq;

## 회고
이전에 que 하나를 사용하고 커스텀 class 내에 카페인지 제과점인지 판단을 하도록 했었는데 이번에 그게 실어서 강제로 que를 두개로 만들어서 계산했었습니다.
그때문에 구현에 대한 복잡도가 올라서 조금 헤매었는데 좋지 못한 행동 같습니다.

이미 풀었던 문제라고 생각해서 그냥 풀었었는데
빠뜨린 조건들이 있어서 시간을  추가로 소요 하였습니다.
문제를 빠뜨림 없이 읽음에 대한 중요성을 다시 한번 상기 하였습니다.

## [pro] 카페2
### Solving Club -> 2026 SSAFY B형 스타티 :D
시도
음료수를 만약 int N으로 관리하고 그것을 쌓는 방식이라면 괜찮지 않을까?
int dring[N]


init
초기 음료 개수 선언
static N 저장

order
mID hash
주문 구성 개수
주문 구성 배열

supply mBeverage
음료의 종류 1? 제작

가장 최근의 주문을 제작 해서 돌려준다

deque? 혹은 링크드list 활용

주문 들어오면
주문 각각의 [1...10] 까지의 배열에 ++ (Deque order_id())
id를 쌓아준다

음료가 들어오면
주문 각각의[1,,,10] 까지의 배열에 ++(배열명 drink)
음료 mid 들어가면 객체 내에서 주문 완료인지 체크
주문 완료 boolean 값 true
라면 Deque order에서 

쌓이면 order_id[drink[주문]] 해주면 mid 리턴

 cancle
1. 일단 이미 완료된 주문인지 확인 완료시 -1리턴
2. 이미 취소된 주문이라면 -1 리턴
3. Deque order_id에서 제거..하지 않고 그대로 두고 id 값만 수정 해서 취소된것인거 표시만 해준다
