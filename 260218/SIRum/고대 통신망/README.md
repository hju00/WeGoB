# [PRO] 고대통신망 문제 풀이

---

## 1.️ 문제 분석

도시 N(≤ 5,000)개와 단방향 도로가 주어진다.
- 초기 도로 K ≤ 10,000
- add ≤ 14,000
- remove ≤ 1,000
- calculate ≤ 5,000

수도 mCapital에서 특정 도시까지 이동할 때:
1.	총 이동 거리 최소
2.	총 거리가 같다면, 그 경로에 포함된 도로 중 가장 긴 도로 길이 최소

도달 불가능하면 -1 반환.

이 문제는 동적 그래프에서 2단계 기준을 가지는 최단경로 문제이다.

---

## 2. 쿼리 특성 분석

▪ init
- 초기 그래프 구성
- 이후 add / remove / calculate가 반복되므로
- 효율적인 동적 업데이트 전략이 필요함

---

▪ add
- 단방향 간선 추가
- 기존 최단거리 구조를 “개선”할 가능성만 존재
- 전체 재계산 대신 부분 갱신 전략 가능

---

▪ remove
- 간선 삭제
- 기존 최단경로가 깨질 수 있음
- 부분 갱신으로 안전하게 처리하기 어려움
- 따라서 전체 재계산 전략이 필요

--- 

▪ calculate
- 현재 그래프 기준으로 결과 반환
- 계산 자체는 O(1)로 설계 가능

---

## 3️.  핵심 알고리즘 아이디어

1. 2단계 기준 다익스트라

일반 다익스트라는 거리만 최소화하지만
이 문제는 다음 두 조건을 동시에 만족해야 한다.
- 1차: 총 거리 최소
- 2차: 그 최단거리 경로들 중 “최장 간선 최소”

따라서 각 도시 v에 대해 다음 두 값을 관리한다.
- dist[v] : 수도 → v까지의 최소 거리
- best[v] : 해당 최소 거리 경로 중 최장 간선 최소값

경로 비교는 다음 우선순위를 따른다.
1.	거리 작은 경로 우선
2.	거리가 같으면 최장 간선이 작은 경로 우선

이 비교 기준을 우선순위 큐 정렬 조건에 그대로 반영하여
다익스트라를 확장한다.

---

2. Lazy Deletion (지연 삭제)

remove 연산을 빠르게 처리하기 위해
간선을 리스트에서 직접 삭제하지 않는다.

대신:
- 간선 객체에 “삭제 여부” 플래그를 둔다.
- remove 시 플래그만 변경한다.
- 다익스트라 탐색 중 삭제된 간선은 무시한다.

이 방식은 삭제를 O(1)로 처리할 수 있게 한다.

---

3. ID 기반 간선 관리

도로 ID가 최대 10^9이므로 배열 사용 불가.

따라서:
- HashMap을 사용하여
- mId → 간선 객체로 매핑

remove 시 해당 간선을 O(1)로 찾을 수 있도록 설계한다.

---

4. add는 부분 갱신, remove는 전체 재계산

- add : 새 간선은 기존 최단거리 구조를 더 좋게 만들 가능성만 있다.

따라서:
- 새 간선의 출발 도시에서부터
- 영향이 전파되는 구간만 부분적으로 다시 다익스트라 수행

→ 전체 재계산보다 훨씬 효율적

---

▪ remove
간선 삭제는 기존 최단경로를 무효화할 수 있다.

어떤 도시들이 영향을 받을지 국소적으로 판단하기 어렵기 때문에
안전하게 전체 다익스트라를 다시 수행한다.

remove 횟수가 적으므로 이 전략이 시간 내에 충분히 가능하다.

---

4.  시간 복잡도 분석
- 전체 재계산: O((N + M) log N)
- add: 대부분 영향 없음 → 매우 빠름
개선되는 경우에만 국소 다익스트라 수행
- remove: O(1) 플래그 처리 + 전체 재계산 1회
- calculate: O(1)

전체 연산 제한 내에서 충분히 통과 가능하다.
