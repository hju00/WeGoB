# [Pro] 고대 왕국 통신망 풀이 정리

## 문제 핵심
- 수도 `mCapital`에서 각 도시까지의 최적 경로를 구한다.
- 최적 기준은 `(총거리, 경로 내 최대간선)`의 사전순 최소:
1. 총거리 최소
2. 총거리 동률이면 최대간선 최소

## 리팩토링 배경
이전에 작성했던 코드는 SWEA 기준에서는 통과했지만, 측정 실행시간이 `2738ms`였다.
이 수치를 보면 실제 B형 환경에서는 같은 로직으로 시간 초과가 발생할 가능성이 높다고 유추할 수 있었다.

이에 따라 아래 방향으로 로직을 수정했다.

- 삭제 시 매번 전체 재계산하지 않고, 영향 여부를 `dirty`로 지연 처리
- `add`는 개선이 발생한 경우에만 증분 다익스트라로 부분 전파
- `calculate` 시점에만 필요한 경우 전체 다익스트라 1회 수행

## 현재 UserSolution 전략
현재 코드는 **증분 갱신 + 지연 재계산(lazy)** 전략으로 구성되어 있다.

## 핵심 모델
- `distSum[v]`: 수도 -> `v` 최소 총거리
- `distMax[v]`: 위 최소 총거리 경로들 중 최대간선 최소값
- `parentEdge[v]`: 현재 최적 경로에서 `v`로 들어오는 마지막 간선
- `dirty`: 삭제로 인해 캐시가 무효화되었는지 표시

## 자료구조
- `graph`: 인접 리스트 (`List<List<Edge>>`)
- `idToEdge`: 도로 ID -> 간선 객체 (`HashMap<Integer, Edge>`)
- `PriorityQueue<State>`: `(sum, maxVal)` 기준 우선순위

## API별 동작
### 1) `init`
- 그래프 초기화 후 전체 다익스트라 1회
- 비교/갱신은 `(sum, max)` 사전순 기준

### 2) `add`
- 새 간선 `s -> e (w)` 추가
- `s`가 도달 가능할 때만 후보 계산
- 후보가 `e`를 개선하면 `e`부터 증분 다익스트라로 영향 구간만 전파
- 따라서 `add`마다 전체 재계산을 피할 수 있다.

### 3) `remove`
- 간선은 즉시 비활성화
- `parentEdge[to] == removedEdge`이면 현재 최적 경로에 영향이 있으므로 `dirty=true`
- 즉시 전체 재계산하지 않고 지연 처리

### 4) `calculate`
- `dirty`일 때만 전체 다익스트라 1회 수행
- `distSum[mCity] == INF`면 `-1`, 아니면 `distMax[mCity]` 반환

## 근거 정리
1. 문제 최적화 정의 자체가 `(sum, maxEdge)` 사전순 최소와 정확히 일치한다.
2. 매 연산 전체 재계산은 제약과 호출 수에서 비효율적이다.
3. 연산 분포(`add` 많음, `remove` 적음)에 증분+지연 전략이 더 맞다.
4. 정확성을 유지하면서 평균 실행량을 줄일 수 있다.

## 복잡도 요약
- `init`: `O((N+E) log E)`
- `add`: 개선이 있을 때만 영향 구간 전파 (평균적으로 전체보다 작음)
- `remove`: `O(1)` (비활성화 + dirty 마킹)
- `calculate`: 보통 `O(1)`, dirty면 `O((N+E) log E)` 1회

## 결론
이 문제 제약에서는
`add=증분`, `remove=지연`, `calculate=필요 시 전체 재계산`
전략이 성능/정확성 균형이 가장 좋다.
