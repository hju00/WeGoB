# [SWEA] 25869 [Pro] 입시예측 (D6) 문제 정리


## 1. 문제 개요
* **목표:** 학생들이 입시 지원을 위해 학력 평가 점수를 입력한 뒤, 현재 상황을 기준으로 어느 학교에 지원하는 것이 유리한 지 제안해주는 프로그램을 구현한다. 신규 학생 지원(`add`), 지원 취소(`erase`)에 의해 실시간으로 변화하는 입시 현황을 관리하고, **추천을 받고자 하는 학생에게 제안하고자 하는 대학 번호를 반환**(`suggest`)해야 한다.
* **조건:** 
    * 학생들은 학력 평가를 통해 받은 5개 과목의 점수를 알고 있다. 또, **학생들은 되도록 번호가 낮은 대학에 입학**하고자 한다.
    * 각 대학은 5개 과목에 대해 가중치를 가진다. 총점은 **학생의 과목별 점수에 가중치를 곱한 뒤 전체 점수를 합산**한 결과이다.
    * 각 학생은 최대 하나의 대학에만 입학 가능하며, 각 **대학은 최대 N명의 학생까지 선발** 가능하다.
    * 각 대학은 지원한 학생들 중 **총점이 가장 높은 N명**만 선발하며, 총점이 동일한 경우 **ID가 낮은 학생**부터 선발한다.
* **제약 사항:**
    * 시간 제한: 3초 / 메모리: 256MB (Heap + Static)
    * 대학별 선발 가능한 최대 학생 수 `N`: $2 \le N \le 1000$
    * 대학 수 `M`: $2 \le M \le 30$
    * 각 대학별 과목 가중치 `mWeight[5][M]`: $0 \le mWeight[i][j] \le 100$ 
    * 학생 번호 `mID`: $1 \le mID \le 20000$
    * 학생의 과목별 점수 `mScores[5]` : $0 \le mScore[i] \le 100$ 
    * 호출 횟수: `add`(20000), `erase`(10000), `suggest`(50000)


## 2. 자료구조 및 알고리즘 설계
- 메서드 호출 횟수가 최대 50000회인 `suggest` 메서드에서의 순회 행위 자체를 지양해야 한다.
- 각 대학은 현재 선발 예상 인원 중 꼴찌가 누구인지, 또 예비 후보 인원 중 1위가 누구인지만 알면 시스템을 유지할 수 있다.
- 새 학생이 지원(`add`)하면 현재 꼴찌와 비교하여 점수가 더 낮은 사람을 밀어내고, 공석이 발생(`erase`)하면 예비 1번인 학생을 다시 선발 명단으로 올려야 하기 때문이다.

* **학생별 정보 관리 및 갱신 (Array):** `mID`가 최대 20000이므로 배열 인덱싱이 가능. **20001** 크기의 배열인 학생별 선발 예정 대학 목록(`univNum`), 정보 삭제 여부(`deleted`), 학생별 학력 평가 점수(`score`)로 학생 정보를 즉시 조회할 수 있도록 관리
* **대학별 선발 명단 및 대기 명단 (PriorityQueue):** 대학은 현재 선발 명단 중 꼴찌와 대기 명단 중 1위만 알고 있으면 됨. 따라서 각각의 명단을 **상반되는 조건의 우선순위 큐**로 관리.
    * 선발 명단은 **성적 오름차순(동일한 경우 학번 내림차순)**으로 관리하여 새 학생이 지원할 때마다 꼴찌와 성적을 비교하고, 더 낮은 쪽이 밀려나는 방식으로 설계
    * 대기 명단은 **성적 내림차순(동일한 경우 학번 오름차순)**으로 관리하여 기존 학생의 지원이 취소될 때마다 대기 명단 중 최고 성적 보유자를 선발 명단으로 등록
* **지연 삭제(Lazy Deletion):** 학생이 지원을 취소한 경우, 우선순위 큐 전체를 돌면서 해당 학생의 정보를 찾는 것은 비효율적. 그러므로 **지연 삭제** 방식을 사용하여, 학생이 지원을 취소한 경우 `deleted` 배열을 이용해 상태를 변경하고 소속 예정 대학의 실제 선발 인원 수를 디카운트만 해둠. 실제 삭제는 `add` 과정에서 꼴찌인 학생을 찾을 때와 `erase` 과정에서 대기 명단 1위 학생을 선발할 때 하는 방식으로 설계


## 3. 핵심 로직 흐름

### 3.1. `init` (초기화)
* **초기화:** 대학별 현재 선발 인원 수(`studentCnt`), 대학별 가중치(`university`), 대학별 선발 및 대기 명단(`status`, `ready`) 초기화

### 3.2. `add` (신규 학생 지원)
* **학력 평가 점수 등록:** 신규 학생의 학력 평가 점수를 본인의 mID번 인덱스에 등록
* **선발 명단 재배치 시작:** 0번 대학부터 선발 명단 포함 가능성 확인
    * **studentCnt[]:** 지원하려는 대학의 현재 인원 수. 정웑 초과시 비교 로직으로 이동
    * **비교:** 현재 학생과, 해당 대학의 꼴찌 학생 간 성적 비교. 우선순위 상 뒤처지는 학생이 현재 대학 선발 명단에서 제외
    * **후순위 대학 지원:** 앞의 과정에서 밀려난 학생이 다음 번호인 대학에 지원
* **탈락:** 모든 대학에 지원한 뒤에도 밀려나면 탈락 처리(그러나 정보 삭제는 아님)

### 3.3. `erase` (기존 학생 지원 취소)
* **조회:** 대상 학생의 정보 삭제 처리, 기존 소속 예정 대학 번호 확인(없으면 즉시 종료), 해당 대학의 실제 합격 예정자 수 디카운트
* **공석 재배치 시작:** 공석이 생긴 대학부터 대기 명단을 이용해 인원 보충
    * **ready[i].poll():** 현재 대기 명단 중 최고 성적인 학생을 재선발하여 인원 보충
    * **oldUniv:** 상위 대학 재배치에 성공한 학생의 기존 소속 예정 대학 번호 확인
    * **공석의 연쇄 발생:** 재배치된 학생의 기존 소속 대학도 공석이 발생하였으므로 해당 대학도 같은 과정을 거침

### 3.4. `suggest` (두 게이트 간 이동시 최단 시간 반환)
* **조회:** `univNum` 배열로부터 대상 학생의 현재 소속 예정 대학을 즉시 조회. 단 -1이면 경쟁에서 밀려난 상태임.