# [SWEA] 25430 [Pro] 커피점 & 제과점 (D6) 문제 정리

## 1. 문제 개요
* **목표:** 건물($N$)과 도로($K$)가 주어질 때, **주택**인 건물 중에서 가장 가까운 **커피점**까지의 거리와 **제과점**까지의 거리가 모두 제한 거리 $R$ 이하인 곳을 찾고, 두 거리 합의 **최솟값**을 구하라.
* **제약 사항:**
    * 시간 제한: 3초 / 메모리: 256MB (Stack 1MB)
    * 건물 수 $N$: $6 \le N \le 10,000$
    * 도로 수 $K$: $6 \le K \le 30,000$
    * 호출 횟수: `init`(1회), `add`(2,000회), `calculate`(100회)

## 2. 알고리즘 설계: Multi-Source Dijkstra
일반적인 다익스트라는 하나의 시작점에서 출발하지만, 이 문제는 여러 개의 커피점과 제과점이 존재합니다.
* **동시 출발:** 모든 커피점과 제과점을 우선순위 큐(Heap)에 초기 비용 0으로 삽입하고 다익스트라를 시작합니다.
* **타입 구분:** 큐에 넣을 때, 해당 경로가 커피점('c')에서 시작된 것인지 제과점('b')에서 시작된 것인지 타입을 함께 저장합니다.
* **가지치기 (Pruning):** 탐색 도중 거리 합이 현재 구한 최솟값(`minDist`) 이상이거나 $R$을 초과하면 탐색을 중단하여 시간을 단축합니다.

## 3. 핵심 로직 흐름 (`calculate` 메서드)
1.  **초기화:** `minDist`는 $2 \\times R + 1$로, 거리 배열 `cDist`, `bDist`는 $R+1$로 초기화.
2.  **Heap 삽입:** 주어진 모든 커피점(M개)과 제과점(P개)을 Heap에 넣음. (거리 0, 각 타입 명시)
3.  **다익스트라 수행:**
    * Heap에서 최소 비용 노드를 꺼냄.
    * **Pruning:** `현재 비용 > R` 이거나 `현재 비용 >= minDist`면 `break`.
    * **방문 체크:** 해당 타입('c' or 'b')으로 이미 더 짧은 거리에 방문했다면 `continue`.
    * **이동 및 갱신:**
        * 다음 건물까지의 거리가 $R$ 이하이고 `minDist`보다 작을 때만 진행.
        * 도착한 건물의 `cDist` 혹은 `bDist` 갱신.
        * **최솟값 갱신:** 만약 반대 타입의 거리가 이미 계산되어 있다면 (`>0` and $\\le R$), 두 거리의 합과 `minDist`를 비교하여 최솟값 갱신.

---