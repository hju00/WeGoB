# SWEA [pro] 승강제 리그

---

### 문제 설명

N명의 선수들이 L개의 리그에 나뉘어 경기를 진행하는 시뮬레이션 문제입니다. 선수들은 고유한 ID(0 ~ N-1)와 능력 값을 가지고 있으며, **능력 값이 높을수록, 능력 값이 같다면 ID가 낮을수록 더 우수한 선수**로 평가됩니다. 초기에는 N명의 선수가 각 리그에 N/L명씩, ID 순서대로 배정됩니다. 문제의 제약 조건으로 **N은 L의 배수**이며, **N/L은 홀수**입니다.

---

### 시뮬레이션 기능

본 문제는 총 3개의 함수를 구현해야 합니다.

1.  **`init(int N, int L, int mAbility[])`**
    -   테스트 케이스의 시작 시점에 호출되는 초기화 함수입니다.
    -   `N`: 총 선수 수 ($9 \le N \le 39,990$)
    -   `L`: 리그 수 ($3 \le L \le 10$)
    -   `mAbility`: 각 선수의 능력 값 배열 ($1 \le mAbility[] \le 10,000$)

2.  **`move()`**
    -   **승강제**를 적용하는 함수입니다.
    -   각 리그에서 능력이 가장 좋은 선수는 바로 위 리그로 승격하고, 능력이 가장 나쁜 선수는 바로 아래 리그로 강등합니다.
    -   0번 리그의 1위 선수와 L-1번 리그의 꼴찌 선수는 이동하지 않습니다.
    -   이동한 모든 선수들의 ID 값 합을 반환합니다.

3.  **`trade()`**
    -   **트레이드 제도**를 적용하는 함수입니다.
    -   각 리그에서 능력이 가장 좋은 선수는 바로 위 리그의 **중간급 선수**와 맞교환됩니다.
    -   중간급 선수는 리그 인원이 $M$명일 때, **$((M+1) / 2)$번째로 능력이 좋은 선수**를 의미합니다.
    -   0번 리그의 1위 선수와 L-1번 리그의 중간급 선수는 이동하지 않습니다.
    -   이동한 모든 선수들의 ID 값 합을 반환합니다.

---

### 예제

아래는 `init`, `move`, `trade` 함수 호출에 따른 선수들의 이동 및 반환 값을 보여주는 예시입니다.

| # | Function | Moved player’s IDs | return |
|---|---|---|---|
| 1 | `init(15, 3, [...])` | - | - |
| 2 | `move()` | `{0, 9, 7, 10}` | 26 |
| 3 | `move()` | `{9, 10, 0, 11}` | 30 |
| 4 | `trade()` | `{4, 11, 8, 12}` | 35 |
| 5 | `trade()` | `{11, 4, 9, 13}` | 37 |
| 6 | `move()` | `{1, 11, 6, 9}` | 27 |
| 7 | `trade()` | `{11, 12, 1, 8}` | 32 |

---

### 제약사항
-   **시간**: C++ / Java 모두 3초
-   **메모리**: 256MB 이내
-   `move()` 함수는 최대 500회 호출됩니다.
-   `trade()` 함수는 최대 1,000회 호출됩니다.
