# [pro] 단어암기장 문제 풀이

## 문제 분석

크게 2가지 기능

1. 단어 추가
- 단어는 다른 단어와 겹치지 않고, 한 행에 적혀야함
- 우선순위 : 1. 행 번호 작은 순, 2. 열 번호 작은 순

2. 단어 제거
- 단어 삭제 시 삭제된 단어가 있던 곳을 빈 공간
- 주어지는 ID가 주어진 ID보다 클 수도 있음

## 알고리즘 선정
단어 DB는 확정 <br>
행 번호만 사용하고 열번호는 안쓰니까 행 번호만 쓰는 자료구조??<br>
예외 case -> <br>
10 X 10 암기장에 길이가 2인 단어 5개 추가<br>
ID 2, 4 단어 제거<br>
남은 공백의 길이는 4 이지만, 넣을 수 있는 단어의 길이는 2임 <br>
<br>
단어를 추가할 때 우선순위가 높은 시작점을 빠르게 찾는 자료구조가 필요함<br>
빌딩이랑 비슷하게 구현하면 될 것같은데?<br>

알고리즘에 대한 결정적인 힌트를 주는 문장이 있다. <br><br>
**※ 암기장의 길이가 긴 경우, [Fig. 5]와 같이 동일한 크기로 잘라서 공책처럼 만들어서 사용한다면 효율적으로 관리가 가능할 것이다.**<br><br>

최대 20,000 X 1,000 크기의 배열을 직접 관리할 수 없고 우선순위를 따져 정렬시켜 놓을 수 없기 때문에 순회를 사용해야한다. -> 버킷 알고리즘<br>
그렇다면 행 안의 단어들은 어떻게 관리해야할까?<br>
이것도 결정적인 힌트가 주어진다.<br><br>

**4. 한 행에 적혀있는 단어들의 최대 수는 60개 이하임을 보장한다.**
<br><br>


단어 추가 :
1. 버킷으로 묶어 버킷 안의 최대 공백 길이를 저장해놓고 버킷을 순회 (버킷의 최대 크기 <= 142)
2. 저장할 단어 길이 이상의 공백 길이를 보유한 버킷을 찾으면 해당 버킷 안의 행들을 순회 (버킷 안 행들의 최대 개수 <= 141)
3. 저장할 단어 길이 이상의 공백 길이를 보유한 행을 찾으면 해당 행의 단어리스트를 순회 (단어리스트의 최대 크기 <= 60)
4. 단어리스트를 순회하면서 단어 사이의 공백 크기를 계산하며, 만족하는 공백 발견 시 단어 삽입 (index 삽입 -> O(N))
5. 행과 버킷의 최대 공백 길이 갱신
<br>

단어 제거 :
1. DB를 통해 해당 단어가 존재하는 행 가져오기
2. 단어리스트를 순회하여 해당 ID의 단어 삭제 (단어리스트의 최대 크기 <= 60)
3. 행과 버킷의 최대 공백 길이 갱신


## 시간 복잡도
- init() X 1
- writeWord() X 50,000 = 620 X 50,000 = 31,000,000
- eraseWord() X 5,000 = 320 X 5,000 = 1,600,000
- 최대 연산 시 32,600,000 정도

## 자료 구조
    static class Word {
        int id, start, end, len;
        public Word(int id, int start, int len) {
            this.id = id;
            this.start = start;
            this.end = start + len;
            this.len = len;
        }
    }

    static int N, M;
    static ArrayList<Word>[] wordList;
    static HashMap<Integer, Integer> idToRow;
    
    static int[] rowMax;
    static int[] bucketMax; 
    static int BUCKET_SIZE;